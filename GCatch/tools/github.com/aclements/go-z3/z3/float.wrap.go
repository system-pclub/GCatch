// Generated by genwrap.go. DO NOT EDIT

package z3

import "runtime"

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
#include <stdlib.h>
*/
import "C"

// Eq returns a Value that is true if l and r are equal.
func (l Float) Eq(r Float) Bool {
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// NE returns a Value that is true if l and r are not equal.
func (l Float) NE(r Float) Bool {
	return l.ctx.Distinct(l, r)
}

// Abs returns the absolute value of l.
func (l Float) Abs() Float {
	// Generated from float.go:499.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_abs(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Float(val)
}

// Neg returns -l.
func (l Float) Neg() Float {
	// Generated from float.go:503.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_neg(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Float(val)
}

// Add returns l+r.
//
// Add uses the current rounding mode.
func (l Float) Add(r Float) Float {
	// Generated from float.go:509.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_add(ctx.c, rm.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// Sub returns l-r.
//
// Sub uses the current rounding mode.
func (l Float) Sub(r Float) Float {
	// Generated from float.go:515.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_sub(ctx.c, rm.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// Mul returns l*r.
//
// Mul uses the current rounding mode.
func (l Float) Mul(r Float) Float {
	// Generated from float.go:521.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_mul(ctx.c, rm.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// Div returns l/r.
//
// Div uses the current rounding mode.
func (l Float) Div(r Float) Float {
	// Generated from float.go:527.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_div(ctx.c, rm.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// MulAdd returns l*r+a (fused multiply and add).
//
// MulAdd uses the current rounding mode on the result of the whole
// operation.
func (l Float) MulAdd(r Float, a Float) Float {
	// Generated from float.go:534.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_fma(ctx.c, rm.c, l.c, r.c, a.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	runtime.KeepAlive(a)
	return Float(val)
}

// Sqrt returns the square root of l.
//
// Sqrt uses the current rounding mode.
func (l Float) Sqrt() Float {
	// Generated from float.go:540.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_sqrt(ctx.c, rm.c, l.c)
	})
	runtime.KeepAlive(l)
	return Float(val)
}

// Rem returns the remainder of l/r.
func (l Float) Rem(r Float) Float {
	// Generated from float.go:544.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_rem(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// Round rounds l to an integral floating-point value according to
// rounding mode rm.
func (l Float) Round(rm RoundingMode) Float {
	// Generated from float.go:549.
	ctx := l.ctx
	rmc := rm.ast(ctx)
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_round_to_integral(ctx.c, rmc.c, l.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(rm)
	return Float(val)
}

// Min returns the minimum of l and r.
func (l Float) Min(r Float) Float {
	// Generated from float.go:553.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_min(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// Max returns the maximum of l and r.
func (l Float) Max(r Float) Float {
	// Generated from float.go:557.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_max(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Float(val)
}

// IEEEEq returns l == r according to IEEE 754 equality.
//
// This differs from Eq, which is true if l and r are identical. In
// contrast, under IEEE equality, ±0 == ±0, while NaN != NaN and ±inf
// != ±inf.
func (l Float) IEEEEq(r Float) Bool {
	// Generated from float.go:565.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_eq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// LT returns l < r.
func (l Float) LT(r Float) Bool {
	// Generated from float.go:569.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_lt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// LE returns l <= r.
func (l Float) LE(r Float) Bool {
	// Generated from float.go:573.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_leq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// GT returns l > r.
func (l Float) GT(r Float) Bool {
	// Generated from float.go:577.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_gt(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// GE returns l >= r.
func (l Float) GE(r Float) Bool {
	// Generated from float.go:581.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_geq(ctx.c, l.c, r.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(r)
	return Bool(val)
}

// IsNormal returns true if l is a normal floating-point number.
func (l Float) IsNormal() Bool {
	// Generated from float.go:585.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_normal(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsSubnormal returns true if l is a subnormal floating-point number.
func (l Float) IsSubnormal() Bool {
	// Generated from float.go:589.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_subnormal(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsZero returns true if l is ±0.
func (l Float) IsZero() Bool {
	// Generated from float.go:593.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_zero(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsInfinite returns true if l is ±∞.
func (l Float) IsInfinite() Bool {
	// Generated from float.go:597.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_infinite(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsNaN returns true if l is NaN.
func (l Float) IsNaN() Bool {
	// Generated from float.go:601.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_nan(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsNegative returns true if l is negative.
func (l Float) IsNegative() Bool {
	// Generated from float.go:605.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_negative(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// IsPositive returns true if l is positive.
func (l Float) IsPositive() Bool {
	// Generated from float.go:609.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_is_positive(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Bool(val)
}

// ToFloat converts l into a floating-point number of a different
// floating-point sort.
//
// If necessary, the result will be rounded according to the current
// rounding mode.
func (l Float) ToFloat(s Sort) Float {
	// Generated from float.go:617.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_to_fp_float(ctx.c, rm.c, l.c, s.c)
	})
	runtime.KeepAlive(l)
	runtime.KeepAlive(s)
	return Float(val)
}

// ToUBV converts l.Round() into an unsigned bit-vector of size 'bits'.
//
// l is first rounded to an integer using the current rounding mode.
// If the result is not in the range [0, 2^bits-1], the result is
// unspecified.
func (l Float) ToUBV(bits int) BV {
	// Generated from float.go:625.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_to_ubv(ctx.c, rm.c, l.c, C.unsigned(bits))
	})
	runtime.KeepAlive(l)
	return BV(val)
}

// ToSBV converts l.Round() into a signed bit-vector of size 'bits'.
//
// l is first rounded to an integer using the current rounding mode.
// If the result is not in the range [-2^(bits-1), 2^(bits-1)-1], the
// result is unspecified.
func (l Float) ToSBV(bits int) BV {
	// Generated from float.go:633.
	ctx := l.ctx
	rm := ctx.rm()
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_to_sbv(ctx.c, rm.c, l.c, C.unsigned(bits))
	})
	runtime.KeepAlive(l)
	return BV(val)
}

// ToReal converts l into a real number.
//
// If l is ±inf, or NaN, the result is unspecified.
func (l Float) ToReal() Real {
	// Generated from float.go:639.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_to_real(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return Real(val)
}

// ToIEEEBV converts l to a bit-vector in IEEE 754-2008 format.
//
// Note that NaN has many possible representations. This conversion
// always uses the same representation.
func (l Float) ToIEEEBV() BV {
	// Generated from float.go:646.
	ctx := l.ctx
	val := wrapValue(ctx, func() C.Z3_ast {
		return C.Z3_mk_fpa_to_ieee_bv(ctx.c, l.c)
	})
	runtime.KeepAlive(l)
	return BV(val)
}
