// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"os"
	"strings"

	"github.com/aclements/go-z3/internal/ops"
)

func main() {
	flagOut := flag.String("o", "", "output to `file`")
	flag.Parse()
	if flag.NArg() > 0 {
		flag.Usage()
		os.Exit(2)
	}

	w := &bytes.Buffer{}
	fmt.Fprintf(w, `// Generated by gen.go. DO NOT EDIT.

package st

import (
	"fmt"
	"math/big"
	"git.gradebot.org/zxl381/goconcurrencychecker/tools/github.com/aclements/go-z3/z3"
)

`)

	fmt.Fprintf(w, "type sorts struct {\n")
	for _, typ := range ops.Types {
		fmt.Fprintf(w, "sort%s z3.Sort\n", typ.StName)
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func initSorts(s *sorts, ctx *z3.Context) {\n")
	for _, typ := range ops.Types {
		arg := ""
		if typ.Bits != 0 {
			arg = fmt.Sprintf("%d", typ.Bits)
		}
		fmt.Fprintf(w, "s.sort%s = ctx.%sSort(%s)\n", typ.StName, typ.SymType, arg)
	}
	fmt.Fprintf(w, "}\n\n")

	for _, typ := range ops.Types {
		genDecl(w, typ)

		for _, binop := range ops.BinOps {
			if binop.Flags&typ.Flags != 0 {
				genBinOp(w, typ, binop)
			}
		}

		for _, unop := range ops.UnOps {
			if unop.Flags&typ.Flags != 0 && unop.Flags&ops.OpPos == 0 {
				genUnOp(w, typ, unop)
			}
		}

		for _, typ2 := range ops.Types {
			genConv(w, typ, typ2)
		}
	}

	writeSource(*flagOut, w.Bytes())
}

func writeSource(filename string, src []byte) {
	fsrc, err := format.Source(src)
	if err != nil {
		fmt.Fprint(os.Stderr, string(src))
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if filename == "" {
		_, err = os.Stdout.Write(fsrc)
	} else {
		err = ioutil.WriteFile(filename, fsrc, 0666)
	}
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func genDecl(w *bytes.Buffer, t ops.Type) {
	symtype := "z3." + t.SymType

	fmt.Fprintf(w, "// %s implements symbolic %s values.\n", t.StName, t.ConType)
	fmt.Fprintf(w, "type %s struct { C %s", t.StName, t.ConType)
	if symtype != "" {
		fmt.Fprintf(w, "; S %s", symtype)
	}
	fmt.Fprintf(w, "}\n\n")

	if symtype == "" {
		return
	}

	fmt.Fprintf(w, "// Any%s returns an unconstrained symbolic %s.\n", t.StName, t.StName)
	fmt.Fprintf(w, "func Any%s(ctx *z3.Context, name string) %s {\n", t.StName, t.StName)
	fmt.Fprintf(w, "	cache := getCache(ctx)\n")
	fmt.Fprintf(w, "	sym := cache.z3.FreshConst(name, cache.sort%s).(%s)\n", t.StName, symtype)
	fmt.Fprintf(w, "	return %s{S: sym}\n", t.StName)
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// String returns x as a string.\n")
	fmt.Fprintf(w, "func (x %s) String() string {\n", t.StName)
	fmt.Fprintf(w, "	if x.IsConcrete() {\n")
	fmt.Fprintf(w, " 		return fmt.Sprint(x.C)\n")
	fmt.Fprintf(w, "	}\n")
	fmt.Fprintf(w, "	return x.S.String()\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// IsConcrete returns true if x is concrete.\n")
	fmt.Fprintf(w, "func (x %s) IsConcrete() bool {\n", t.StName)
	fmt.Fprintf(w, "	return x.S.Context() == nil\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// Eval returns x's concrete value in model m.\n")
	fmt.Fprintf(w, "// This also evaluates x with model completion.\n")
	fmt.Fprintf(w, "func (x %s) Eval(m *z3.Model) %s {\n", t.StName, t.ConType)
	fmt.Fprintf(w, "	if x.IsConcrete() { return x.C }\n")
	fmt.Fprintf(w, "	c := m.Eval(x.S, true).(%s)\n", symtype)
	switch {
	case t.Flags&ops.IsBool != 0:
		fmt.Fprintf(w, "val, ok := c.AsBool()\n")
	case t.Flags&ops.IsUnsigned != 0:
		fmt.Fprintf(w, "val, ok, _ := c.AsUint64()\n")
	case t.Flags&ops.IsInteger != 0:
		fmt.Fprintf(w, "val, ok, _ := c.AsInt64()\n")
	case t.Flags&ops.IsBigInt != 0:
		fmt.Fprintf(w, "val, ok := c.AsBigInt()\n")
	case t.Flags&ops.IsBigRat != 0:
		fmt.Fprintf(w, "if c2, _, ok := c.Approx(RealApproxDigits); ok { c = c2 }\n")
		fmt.Fprintf(w, "val, ok := c.AsBigRat()\n")
	}
	fmt.Fprintf(w, "	if !ok { panic(%q + c.String()) }\n", "model evaluation produced non-concrete value ")
	fmt.Fprintf(w, "	return (%s)(val)\n", t.ConType)
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// sym returns x's symbolic value, creating it if necessary.\n")
	fmt.Fprintf(w, "func (x %s) sym(c *cache) %s {\n", t.StName, symtype)
	fmt.Fprintf(w, "if !x.IsConcrete() { return x.S }\n")
	switch symtype {
	case "z3.Bool":
		fmt.Fprintf(w, "return c.z3.FromBool(x.C)\n")
	case "z3.BV":
		// TODO: Is this right for unsigned types?
		fmt.Fprintf(w, "return c.z3.FromInt(int64(x.C), c.sort%s).(z3.BV)\n", t.StName)
	case "z3.Int":
		fmt.Fprintf(w, "return c.z3.FromBigInt(x.C, c.sort%s).(z3.Int)\n", t.StName)
	case "z3.Real":
		fmt.Fprintf(w, "return c.z3.FromBigRat(x.C)\n")
	}
	fmt.Fprintf(w, "}\n\n")
}

func genBinOp(w *bytes.Buffer, t ops.Type, op ops.Op) {
	resType := t.StName
	if op.Flags&ops.OpCompare != 0 {
		resType = "Bool"
	}

	rType := t.StName
	if op.Flags&ops.OpShift != 0 {
		// Right operand is an unsigned int.
		rType = "Uint64"
	}

	fmt.Fprintf(w, "func (x %s) %s(y %s) %s {\n", t.StName, op.Method, rType, resType)

	// If x and y are concrete, do concrete operation.
	fmt.Fprintf(w, "if x.IsConcrete() && y.IsConcrete() {\n")
	if t.Flags&(ops.IsBigInt|ops.IsBigRat) == 0 {
		fmt.Fprintf(w, "return %s{C: x.C %s y.C}\n", resType, op.Op)
	} else if op.Flags&ops.OpCompare == 0 {
		fmt.Fprintf(w, "z := %s{C: new(%s)}\n", resType, strings.TrimLeft(t.ConType, "*"))
		fmt.Fprintf(w, "z.C.%s(x.C, y.C)\n", op.Method)
		fmt.Fprintf(w, "return z\n")
	} else {
		fmt.Fprintf(w, "return Bool{C: x.C.Cmp(y.C) %s 0}\n", op.Op)
	}
	fmt.Fprintf(w, "}\n")

	// Otherwise, do operation symbolically.
	fmt.Fprintf(w, "ctx := x.S.Context()\n")
	fmt.Fprintf(w, "if ctx == nil { ctx = y.S.Context() }\n")
	fmt.Fprintf(w, "cache := getCache(ctx)\n")
	symop := op.Method
	if symop == "Quo" && t.Flags&(ops.IsInteger|ops.IsBigRat) != 0 {
		// On bit-vectors and reals, Go's / operator is
		// equivalent to Z3's [SU]Div.
		symop = "Div"
	}
	if op.Flags&ops.Z3SignedPrefix != 0 {
		switch {
		case t.Flags&ops.IsUnsigned != 0:
			symop = "U" + symop
		case t.Flags&ops.IsInteger != 0:
			symop = "S" + symop
		case t.Flags&(ops.IsFloat|ops.IsBigInt|ops.IsBigRat) != 0:
			symop = symop
		default:
			panic("bad symop " + symop)
		}
	}
	rs := "y.sym(cache)"
	if op.Flags&ops.OpShift != 0 {
		fmt.Fprintf(w, "var rs z3.BV\n")
		rs = "rs"
		// Short-circuit if right is concrete.
		fmt.Fprintf(w, "if y.IsConcrete() {\n")
		fmt.Fprintf(w, "	if y.C >= %d {\n", t.Bits)
		fmt.Fprintf(w, "		return %s{C: 0}\n", resType)
		fmt.Fprintf(w, "	}\n")
		if t.Bits == 64 {
			fmt.Fprintf(w, "}\n")
			// Size matches. There are no truncation
			// issues, so just make y symbolic.
			fmt.Fprintf(w, "rs = y.sym(cache)\n")
		} else if t.Bits < 64 {
			// Z3 needs it to be the same width as the
			// left operand.
			//
			// If it's concrete, we've already
			// overflow-checked it, so we can just
			// truncate the concrete value and use that.
			fmt.Fprintf(w, "	rs = Uint%d{C: uint%d(y.C)}.sym(cache)\n", t.Bits, t.Bits)
			fmt.Fprintf(w, "} else {\n")
			// If it's symbolic, we can't just truncate it
			// because the value might be large, so
			// collapse the top many bits into one top
			// bit.
			fmt.Fprintf(w, "	rs = y.sym(cache)\n")
			fmt.Fprintf(w, "	rs = rs.Extract(63, %d).AnyBits().Concat(rs.Extract(%d, 0))\n", t.Bits-1, t.Bits-2)
			fmt.Fprintf(w, "}\n")
		}
	}
	expr := fmt.Sprintf("x.sym(cache).%s(%s)", symop, rs)
	switch symop {
	case "AndNot":
		// There's no Z3 method for this one, but it's easy to
		// build up.
		expr = "x.sym(cache).And(y.Not().sym(cache))"
	case "Quo":
		// This is messy. Z3's Int Div rounds toward -inf, but
		// Go's "/" and big.Int.Quo round toward 0.
		//
		// x div y + (x mod y == 0 || x >= 0 ? 0 : (y >= 0 ? 1 : -1))
		fmt.Fprintf(w, "xs, ys := x.sym(cache), y.sym(cache)\n")
		fmt.Fprintf(w, "zero := cache.z3.FromInt(0, cache.sort%s).(z3.Int)\n", t.StName)
		fmt.Fprintf(w, "one := cache.z3.FromInt(1, cache.sort%s).(z3.Int)\n", t.StName)
		expr = "xs.Div(ys).Add(xs.Mod(ys).Eq(zero).Or(xs.GE(zero)).IfThenElse(zero, ys.GE(zero).IfThenElse(one, one.Neg())).(z3.Int))"
	case "Rem":
		if t.Flags&ops.IsBigInt == 0 {
			break
		}
		// This is even messier. :(
		fmt.Fprintf(w, "xs, ys := x.sym(cache), y.sym(cache)\n")
		fmt.Fprintf(w, "zero := cache.z3.FromInt(0, cache.sort%s).(z3.Int)\n", t.StName)
		fmt.Fprintf(w, "one := cache.z3.FromInt(1, cache.sort%s).(z3.Int)\n", t.StName)
		expr = "xs.Sub(xs.Div(ys).Add(xs.Mod(ys).Eq(zero).Or(xs.GE(zero)).IfThenElse(zero, ys.GE(zero).IfThenElse(one, one.Neg())).(z3.Int)).Mul(ys))"
	}
	fmt.Fprintf(w, "	return %s{S: %s}\n", resType, expr)
	fmt.Fprintf(w, "}\n\n")
}

func genUnOp(w *bytes.Buffer, t ops.Type, op ops.Op) {
	fmt.Fprintf(w, "func (x %s) %s() %s {\n", t.StName, op.Method, t.StName)

	// If x is concrete, do concrete operation.
	fmt.Fprintf(w, "if x.IsConcrete() {\n")
	if t.Flags&(ops.IsBigInt|ops.IsBigRat) == 0 {
		fmt.Fprintf(w, "return %s{C: %sx.C}\n", t.StName, op.Op)
	} else {
		fmt.Fprintf(w, "z := %s{C: new(%s)}\n", t.StName, strings.TrimLeft(t.ConType, "*"))
		fmt.Fprintf(w, "z.C.%s(x.C)\n", op.Method)
		fmt.Fprintf(w, "return z\n")
	}
	fmt.Fprintf(w, "}\n")

	// Otherwise, do symbolic operation.
	fmt.Fprintf(w, "return %s{S: x.S.%s()}\n", t.StName, op.Method)
	fmt.Fprintf(w, "}\n\n")
}

func genConv(w io.Writer, from, to ops.Type) {
	if from.Flags&to.Flags&ops.IsInteger == 0 {
		return
	}
	op := ""
	switch {
	case to.Bits < from.Bits:
		op = fmt.Sprintf("Extract(%d, 0)", to.Bits-1)
	case from.Flags&ops.IsUnsigned != 0:
		op = fmt.Sprintf("ZeroExtend(%d)", to.Bits-from.Bits)
	case from.Flags&ops.IsInteger != 0:
		op = fmt.Sprintf("SignExtend(%d)", to.Bits-from.Bits)
	}
	fmt.Fprintf(w, "func (x %s) To%s() %s {\n", from.StName, to.StName, to.StName)
	fmt.Fprintf(w, "	if x.IsConcrete() {\n")
	fmt.Fprintf(w, "		return %s{C: %s(x.C)}\n", to.StName, to.ConType)
	fmt.Fprintf(w, "	}\n")
	fmt.Fprintf(w, "	return %s{S: x.S.%s}\n", to.StName, op)
	fmt.Fprintf(w, "}\n\n")
}
